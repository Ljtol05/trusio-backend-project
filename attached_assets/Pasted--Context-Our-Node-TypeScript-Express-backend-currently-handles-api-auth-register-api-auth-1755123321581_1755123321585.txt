### Context
Our Node + TypeScript Express backend currently handles `/api/auth/register`, `/api/auth/login`, and the KYC endpoints. We now need email verification and updated registration logic to align with the new front‑end flow. We’re using Prisma for the database.

### Tasks

1. **Extend the User model** (if it doesn’t already exist). In `prisma/schema.prisma`, add boolean fields `emailVerified` (default `false`) and `kycApproved` (default `false`), and a string field `verificationCode` (nullable). Run a migration to apply these changes.

2. **Create an email service**:
   - Implement a simple mailer in `src/lib/email.ts` using nodemailer or a mock (for now, it can log the code to the console to simulate sending). Expose a function `sendVerificationEmail(email: string, code: string): Promise<void>`.

3. **Modify registration endpoint** (`POST /api/auth/register` in `src/routes/auth.ts`):
   - Accept `{ name, email, password }`.
   - Validate input; hash the password (use bcrypt).
   - Generate a 6‑digit numeric `verificationCode`.
   - Create a new user with `emailVerified:false`, `verificationCode:code`, and store the hashed password.
   - Call `sendVerificationEmail(email, code)`.
   - Respond with a 201 status and a message like `{ message: "Verification email sent." }`.
   - Do not issue an auth token yet.

4. **Add email verification endpoint** (`POST /api/auth/verify-email`):
   - Accept `{ email, code }`.
   - Look up the user by email.
   - If the user doesn’t exist, return 404. If they are already verified, return 400.
   - Check that `verificationCode` matches. If not, return 400.
   - Update the user record: set `emailVerified:true` and clear `verificationCode`.
   - Generate an auth token (JWT or session) and return it in the response body along with `{ message: "Email verified." }`. The frontend will store this token.

5. **Add resending verification code** (`POST /api/auth/resend-verification`):
   - Accept `{ email }`.
   - Generate a new `verificationCode` for the user and call `sendVerificationEmail`.
   - Overwrite the old code in the database.
   - Return `{ message: "Verification email resent." }`.

6. **Update login endpoint** (`POST /api/auth/login`):
   - Require `emailVerified:true`. If not verified, return 403 with `{ message: "Please verify your email." }`.
   - Require `kycApproved:true`. If KYC is pending or rejected, return 403 with `{ message: "Please complete KYC." }`.
   - If both conditions are met, generate and return the auth token. (Keep existing password check.)

7. **Update KYC flow**:
   - When `/api/kyc/start` is called, set the user’s `kycApproved:false` until the webhook updates it.
   - When a KYC webhook (e.g. `POST /api/webhooks/kyc`) marks a user as approved, set their `kycApproved:true`.
   - Users should only be allowed to call login after both `emailVerified` and `kycApproved` are true.

8. **Test cases**:
   - Add unit tests for the new routes: registration creates the user and stores a code; verify-email validates the code and sets `emailVerified:true`; resend-verification generates a new code; login blocks unverified users; login blocks users pending KYC; login succeeds for verified + KYC-approved users.

9. **Documentation**:
   - Update `API.md` to describe the new endpoints (request bodies, responses, status codes).
   - If necessary, add new request/response types to `src/types/dto.ts`.

### Notes
- Keep all sensitive values (SMTP credentials, JWT secrets) in environment variables loaded via `dotenv` and referenced from `src/config/env.ts`.
- For the email service, a simple console log of the code is acceptable for local development.