generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id                       Int           @id @default(autoincrement())
  name                     String
  email                    String        @unique
  password                 String?
  emailVerified            Boolean       @default(false)
  verificationCode         String?
  phoneVerified            Boolean       @default(false)
  phone                    String?
  phoneVerificationCode    String?
  kycApproved              Boolean       @default(false)
  kycData                  String?       // Changed from Json to String for SQLite
  createdAt                DateTime      @default(now())
  updatedAt                DateTime      @updatedAt

  envelopes                Envelope[]
  cards                    Card[]
  transactions             Transaction[]
  transfers                Transfer[]
  rules                    Rule[]
  routingConfig            RoutingConfig?
  userMemories             UserMemory[]
  serviceAccounts          ServiceAccount[]
}

model Envelope {
  id             Int      @id @default(autoincrement())
  name           String
  icon           String?
  color          String?  @default("blue")
  balanceCents   Int      @default(0)
  spentThisMonth Int      @default(0)
  order          Int      @default(0)
  isActive       Boolean  @default(true)
  userId         Int
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  user              User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  transactionsFrom  Transaction[]     @relation("FromEnvelope")
  transfersFrom     Transfer[]        @relation("TransferFrom")
  transfersTo       Transfer[]        @relation("TransferTo")
  rules             Rule[]
  card              Card?

  @@unique([userId, name])
  @@map("envelopes")
}

model Transaction {
  id              Int      @id @default(autoincrement())
  amountCents     Int      // negative for spend, positive for refund
  merchant        String
  mcc             String?
  location        String?
  reason          String?
  status          String   @default("SETTLED") // PENDING, SETTLED, DECLINED
  wasHold         Boolean  @default(false)
  holdAmountCents Int?
  externalId      String?  @unique
  envelopeId      Int?
  userId          Int
  cardId          Int?
  authorizedAt    DateTime?
  postedAt        DateTime?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  envelope Envelope? @relation("FromEnvelope", fields: [envelopeId], references: [id])
  card     Card?     @relation(fields: [cardId], references: [id])

  @@map("transactions")
}

model Transfer {
  id           Int      @id @default(autoincrement())
  amountCents  Int
  note         String?
  fromId       Int?
  toId         Int?
  userId       Int
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  user         User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  fromEnvelope Envelope? @relation("TransferFrom", fields: [fromId], references: [id])
  toEnvelope   Envelope? @relation("TransferTo", fields: [toId], references: [id])

  @@map("transfers")
}

model Rule {
  id         Int      @id @default(autoincrement())
  priority   Int      @default(0)
  mcc        String?  // equals match
  merchant   String?  // contains match (case-insensitive)
  geofence   String?  // location match
  envelopeId Int?
  enabled    Boolean  @default(true)
  userId     Int
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  envelope Envelope? @relation(fields: [envelopeId], references: [id], onDelete: Cascade)

  @@map("rules")
}

model Card {
  id         Int     @id @default(autoincrement())
  last4      String
  token      String? // tokenized PAN
  label      String?
  inWallet   Boolean @default(false)
  envelopeId Int?    @unique // 1:1 relationship with envelope
  userId     Int
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  user         User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  envelope     Envelope?     @relation(fields: [envelopeId], references: [id])
  transactions Transaction[]

  @@map("cards")
}

model RoutingConfig {
  id               Int    @id @default(autoincrement())
  spendMode        String @default("SMART_AUTO") // LOCKED, SMART_AUTO, GENERAL_POOL
  lockedEnvelopeId Int?
  useGeneralPool   Boolean @default(true)
  bufferCents      Int     @default(0)
  confidence       Int     @default(75) // 0-100 slider
  userId           Int     @unique
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("routing_configs")
}

model UserMemory {
  id        Int      @id @default(autoincrement())
  userId    Int
  type      String   // conversation, bank_statement, spending_pattern, goal
  content   String   // The actual content/text
  embedding String?  // JSON array of embedding vector
  metadata  String?  // JSON metadata
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("user_memories")
}

model VerificationCode {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  codeHash  String
  expiresAt DateTime
  createdAt DateTime @default(now())
}

model ServiceAccount {
  id          Int      @id @default(autoincrement())
  userId      Int
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  name        String
  description String?
  tokenHash   String   @unique
  permissions String   // JSON string of permission array for SQLite compatibility
  enabled     Boolean  @default(true)
  lastUsedAt  DateTime?
  expiresAt   DateTime
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@unique([userId, name])
}